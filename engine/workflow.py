import yaml
from engine.core import SovereignEngine

# The SVM (State Vector Machine)
class WorkflowExecutor:
    def __init__(self, engine: SovereignEngine, interactive=False):
        self.engine = engine
        self.interactive = interactive
        self.memory = {}

    def execute_step(self, step, context):
        # Resolve input from previous steps
        if "input_from" in step:
            source_id = step["input_from"]
            if source_id in self.memory:
                payload = self.memory[source_id].get("payload", "")
                # For write action, this becomes content
                if step.get("action") == "write":
                    step["content"] = payload
                # For provider action, this appends to context
                else:
                    context += f"\nInput from {source_id}: {payload}"

        if "condition" in step:
            # Branching Logic
            check = self.engine.process_signal("gemini", f"Evaluate boolean: {step['condition']} based on {context}")
            if "true" not in check['payload'].lower():
                return None

        if "loop" in step:
            # Recursive Loop
            results = []
            for item in step['loop']:
                results.append(self.execute_workflow(step['sub_workflow'], context=f"{context} Item: {item}"))
            return results

        # Standard Execution
        if self.interactive and step.get("confirm", False):
            input(f"Authorize execution of step: {step['id']}? [y/N] ")
            
        # Handle custom actions before falling back to normal provider calls
        if step.get("action") == "write":
            # Expected keys: filename, content (generated by a previous provider step)
            filename = step["filename"]
            content = step["content"]
            from engine.tools import write_to_workspace
            written_path = write_to_workspace(filename, content)
            return {"status": "success", "payload": f"File written to {written_path}"}
        return self.engine.process_signal(step['provider'], step['prompt'], context)

    def execute_workflow(self, workflow_yaml, context=""):
        spec = yaml.safe_load(workflow_yaml)
        for step in spec['steps']:
            result = self.execute_step(step, context)
            
            # Store result in memory
            if "id" in step and result:
                self.memory[step["id"]] = result

            # If the step produced a payload (e.g., provider or write), store it for templating
            if isinstance(result, dict) and 'payload' in result:
                step['payload'] = result['payload']
            # Update context if needed (optional, not used currently)
            # context = result.get('payload', context)

