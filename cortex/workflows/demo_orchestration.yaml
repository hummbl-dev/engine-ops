name: "Multi-Step Orchestration Demo"
description: "Complete development pipeline: generate code → tests → docs → validation"

steps:
  # Step 1: Generate the main application code
  - id: generate_api
    provider: gemini
    prompt: |
      Generate a complete Flask REST API for a Task Management system.
      
      Requirements:
      - Flask app with error handling
      - Endpoints: GET /tasks, POST /tasks, GET /tasks/<id>, PUT /tasks/<id>, DELETE /tasks/<id>
      - In-memory storage (tasks list)
      - JSON request/response
      - Input validation
      - Proper HTTP status codes
      - CORS enabled
      
      Return ONLY the Python code, NO markdown, NO explanations.
      
  - id: save_api
    action: write
    filename: "orchestration_demo/app.py"
    input_from: generate_api

  # Step 2: Generate comprehensive tests based on the API
  - id: generate_tests
    provider: gemini
    prompt: |
      Based on this Flask API code, generate comprehensive pytest tests:
      
      ${generate_api.payload}
      
      Requirements:
      - Test all endpoints (GET, POST, PUT, DELETE)
      - Test error cases (404, 400, etc.)
      - Test input validation
      - Use pytest fixtures for test client
      - Include test for CORS headers
      - Minimum 10 test cases
      
      Return ONLY the Python test code, NO markdown, NO explanations.
      
  - id: save_tests
    action: write
    filename: "orchestration_demo/test_app.py"
    input_from: generate_tests

  # Step 3: Generate API documentation based on the code  
  - id: generate_docs
    provider: gemini
    prompt: |
      Based on this Flask API code, generate a comprehensive README.md:
      
      ${generate_api.payload}
      
      Include:
      - Project title and description
      - Installation instructions
      - API endpoint documentation (method, path, request/response format)
      - Example curl commands for each endpoint
      - How to run tests
      - Dependencies list
      
      Return ONLY the markdown, NO code blocks for the API itself.
      
  - id: save_docs
    action: write
    filename: "orchestration_demo/README.md"
    input_from: generate_docs

  # Step 4: Generate a requirements.txt based on the code
  - id: generate_requirements
    provider: gemini
    prompt: |
      Based on this Flask API code, generate a requirements.txt file:
      
      ${generate_api.payload}
      
      Include:
      - Flask and its version
      - Flask-CORS
      - pytest and pytest-flask for testing
      - Any other dependencies needed
      
      Return ONLY the requirements.txt content, NO explanations.
      
  - id: save_requirements
    action: write
    filename: "orchestration_demo/requirements.txt"
    input_from: generate_requirements

  # Step 5: Generate a code review/validation report
  - id: generate_review
    provider: gemini
    prompt: |
      Review this Flask API code for quality, security, and best practices:
      
      ${generate_api.payload}
      
      Provide:
      - Code quality assessment (1-10)
      - Security concerns (if any)
      - Best practices compliance
      - Suggested improvements
      - Overall readiness for production
      
      Format as a structured code review report in markdown.
      
  - id: save_review
    action: write
    filename: "orchestration_demo/CODE_REVIEW.md"
    input_from: generate_review

  # Step 6: Generate a deployment guide based on everything
  - id: generate_deployment
    provider: gemini
    prompt: |
      Based on this Flask API and its tests, create a deployment guide:
      
      API Code:
      ${generate_api.payload}
      
      Create a deployment guide (markdown) that includes:
      - Local development setup
      - Running the application
      - Running tests
      - Environment variables needed
      - Production deployment considerations (WSGI server, reverse proxy)
      - Docker deployment (if applicable)
      
      Return ONLY the markdown content.
      
  - id: save_deployment
    action: write
    filename: "orchestration_demo/DEPLOYMENT.md"
    input_from: generate_deployment
